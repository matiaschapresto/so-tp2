\section{Detalles de implementaci\'on}
\label{sec:Imp}
En esta secci\'on vamos a dar detalle de nuestra implementaci\'on del servidor multicliente. Para sincronizar todos los threads se usan las variables presentes a continuaci\'on:

\lstinputlisting[language=C, frame=single, firstline=20, lastline=32]{../codigo/servidor_multi.c}

A lo largo de la secci\'on vamos a ir justificando la presencia de cada una de ellas.

\subsection{Implementando el servidor \textbf{servidor\_multi.c}}
Para implementar el servidor con soporte para m\'ultiples clientes nos basamos en el presente en \textbf{servidor\_mono.c}, tal y como sugiri\'o la c\'atedra.
La idea principal es que al momento de conectarse el cliente, levantemos un thread con la rutina que ejecutar\'ia el mismo en un servidor mono cliente. A continuaci\'on se muestra el c\'odigo:

\lstinputlisting[language=C, frame=single, lastline=20]{../codigo/servidor_multi.c}

Para poder pasarle par\'ametros a la rutina asociada a los threads, tuvimos que cambiar su interf\'az, es decir, antes la misma era:

\lstinputlisting[language=C, frame=single, firstline=97, lastline=97]{../codigo/servidor_mono.c}

y la cambiamos por:

\lstinputlisting[language=C, frame=single, firstline=216, lastline=216]{../codigo/servidor_multi.c}

Luego de ese cambio de interf\'az el c\'odigo de \textbf{atendedor\_de\_alumno} est\'a preparado para ser llamado desde un thread. Como hab\'iamos mencioado previamente, la idea ser\'ia crear un thread mientras me sigan llegando pedidos de conexi\'on al socket del server.

La funci\'on principal presenta la siguiente implementaci\'on:

\lstinputlisting[language=C, frame=single, firstline=274, lastline=339]{../codigo/servidor_multi.c}

Vemos como en el \textbf{for(;;)} se crean los threads, uno por cada conexi\'on con un cliente. Ac\'a es donde cobra valor la estructura definida previamente, \emph{thread\_args}, que la usamos para pasarle los par\'ametros necesario que la funci\'on \textbf{atendedor\_de\_alumno} necesita para funcionar.

\subsection{Herramientas usadas/cambiadas para realizar pruebas}
Para poder testear la implementaci\'on se hizo un script en \emph{bash} para que corra una cierta cantidad de clientes en simult\'aneo. Adem\'as se hicieron unas ligeras modificaciones al \emph{server\_tester.py} provisto por la c\'atedra. El cambio consiste en hacer que cada vez que se ejecute \emph{server\_tester.py} se elija un nombre de pa\'is distinto. Luego, si ejecutamos 20 clientes en simult\'aneo vamos a tener una visi\'on mas clara de quienes est\'an ejecutando ya que no todos se llaman de la misma manera.

El script de \emph{bash} es el siguiente:

\lstinputlisting[language=bash, frame=single]{../codigo/test_server.sh}
 
 El uso es sencillo, se debe ejecutar pas\'andole como parametro la cantidad de alumnos que queremos que ingresen al aula, o m\'as t\'ecnicamente, la cantidad de clientes que queremos que se conecten al servidor.
 
Por otro lado, en \emph{server\_tester.py} se incluy\'o el modulo \emph{random} al principio para poder obtener un pa\'is al azar de la n-tupla de pa\'ises.
  
\lstinputlisting[language=Python, lastline=13, frame=single]{../codigo/server_tester.py}

La obtenci\'on del nuevo pa\'is para el cliente se hace de la siguiente manera:
\lstinputlisting[language=Python, firstline=86, lastline=89, frame=single]{../codigo/server_tester.py}

La idea de las \'ultimas l\'ineas era crear una posici\'on inicial random para cada cliente creado. El motivo no es otro que poder tener diferentes casos de prueba, y no s\'olo que todos intenten ingresar a la misma posici\'on. Notar que si bien esta implementaci\'on no garantiza que no se repitan nombres de pa\'ises, al menos es mucho mejor que tener que lidiar con m\'ultiples clientes conectados mostrando todos el mismo nombre. Con estas peque\~nas modificaciones se nos facilit\'o mucho el testing del servidor.

% section  (end)